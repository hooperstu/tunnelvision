<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Anaglyph Tunnel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
      /* --- UPDATED: More robust full-screen styling for all devices --- */
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #000;
        font-family: 'Inter', sans-serif;
        color: white;
      }
      canvas {
        display: block;
      }
      .instructions {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px 20px;
        border-radius: 10px;
        font-size: 14px;
        text-align: center;
        pointer-events: none; /* Make sure it doesn't block mouse events for the canvas */
      }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
     <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div class="instructions" id="instructions">
        Hi, put on your 3D glasses and enjoy the ride.
    </div>
    <script>
      // This is p5.js "instance mode".
      const sketch = (p) => {
        // Manual anaglyph implementation variables
        let leftEye, rightEye;
        const eyeSeparation = 40; // How far apart the "eyes" are for the 3D effect

        const rings = [];
        const totalRings = 30; 
        let camZ = 0; 
        const flightSpeed = 40;

        const stars = [];
        const totalStars = 125;

        const ringSpacing = 300;
        const tunnelLength = totalRings * ringSpacing;

        p.setup = function() {
          p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
          p.noStroke();
          
          // Create off-screen graphics for each eye
          leftEye = p.createGraphics(p.width, p.height, p.WEBGL);
          rightEye = p.createGraphics(p.width, p.height, p.WEBGL);
          leftEye.noStroke();
          rightEye.noStroke();
          
          // Create the initial set of rings for the tunnel
          for (let i = 0; i < totalRings; i++) {
            rings.push(new TunnelRing(i * -ringSpacing));
          }
          
          for (let i = 0; i < totalStars; i++) {
              stars.push({
                  x: p.random(-4000, 4000),
                  y: p.random(-4000, 4000),
                  z: p.random(0, -tunnelLength),
                  color: p.color(p.random(200, 255), p.random(200, 255), p.random(220, 255)),
                  twinkleOffset: p.random(p.TWO_PI),
                  twinkleSpeed: p.random(0.05, 0.2) 
              });
          }
        };

        p.draw = function() {
          camZ -= flightSpeed;

          // --- REMOVED: Recycling logic is moved into the drawing functions ---

          // Draw the scene twice, once for each eye
          drawScene(leftEye, -eyeSeparation / 2); // Left eye is offset to the left
          drawScene(rightEye, eyeSeparation / 2);  // Right eye is offset to the right

          // Composite the two eye images onto the main canvas
          p.background(0); // Clear the main canvas
          p.blendMode(p.ADD); // Use ADD blend mode to combine the colors

          p.push();
          p.tint(255, 0, 0); // Apply red filter
          p.image(leftEye, -p.width / 2, -p.height / 2);
          p.pop();

          p.push();
          p.tint(0, 255, 255); // Apply cyan filter
          p.image(rightEye, -p.width / 2, -p.height / 2);
          p.pop();
          
          p.blendMode(p.BLEND); // Reset blend mode
        };

        function drawStarfoxGrid(pg) {
            pg.push();
            pg.strokeWeight(2);

            const gridSize = 12000;
            const gridLines = 40;
            const gridSpacing = gridSize / gridLines;
            const gridY = 800;

            pg.stroke(0, 255, 255, 150);
            for (let i = 0; i <= gridLines; i++) {
                const pos = -gridSize / 2 + i * gridSpacing;
                pg.line(pos, gridY, -gridSize*2, pos, gridY, gridSize*2);
            }
            const startZ = camZ - (camZ % gridSpacing);
            for (let i = 0; i < 80; i++) {
                const pos = startZ - i * gridSpacing;
                pg.line(-gridSize/2, gridY, pos, gridSize/2, gridY, pos);
            }

            pg.stroke(255, 0, 255, 150);
            for (let i = 0; i <= gridLines; i++) {
                const pos = -gridSize / 2 + i * gridSpacing;
                pg.line(pos, -gridY, -gridSize*2, pos, -gridY, gridSize*2);
            }
            for (let i = 0; i < 80; i++) {
                const pos = startZ - i * gridSpacing;
                pg.line(-gridSize/2, -gridY, pos, gridSize/2, -gridY, pos);
            }

            pg.pop();
        }
        
        function drawScene(pg, eyeX) {
          pg.background(0, 0, 10);
          
          const cameraX = eyeX;
          const cameraY = 0;

          const lookAtX = eyeX;
          const lookAtY = 0;
          const lookAtZ = camZ - 1000;

          pg.camera(cameraX, cameraY, camZ, 
                    lookAtX, lookAtY, lookAtZ, 
                    0, 1, 0);

          pg.ambientLight(50, 50, 50);
          pg.pointLight(255, 255, 255, 0, 0, camZ + 200);

          drawStarfoxGrid(pg);

          pg.push();
          pg.noFill(); 
          for(const star of stars) {
              // --- FIX: Star recycling logic is now here ---
              if (star.z > camZ) {
                  star.z -= tunnelLength;
                  star.x = p.random(-4000, 4000);
                  star.y = p.random(-4000, 4000);
              }

              const twinkleSize = 4 + p.sin(p.frameCount * star.twinkleSpeed + star.twinkleOffset) * 3;
              pg.strokeWeight(twinkleSize);
              pg.stroke(star.color);
              
              pg.point(star.x, star.y, star.z);
          }
          pg.pop();

          for (const ring of rings) {
            ring.updateAndDisplay(pg);
          }
        }
        
        p.windowResized = function() {
          p.resizeCanvas(p.windowWidth, p.windowHeight);
          leftEye = p.createGraphics(p.width, p.height, p.WEBGL);
          rightEye = p.createGraphics(p.width, p.height, p.WEBGL);
          leftEye.noStroke();
          rightEye.noStroke();
        };

        class TunnelRing {
          constructor(z) {
            this.z = z;
            this.randomize();
          }

          randomize() {
            this.angle = p.random(p.TWO_PI);
            this.radius = p.random(300, 1000);
            
            this.x = p.cos(this.angle) * this.radius;
            this.y = p.sin(this.angle) * this.radius;
            
            this.size = p.random(80, 150);
            
            this.rotation = p.createVector(p.random(p.TWO_PI), p.random(p.TWO_PI), p.random(p.TWO_PI));
            this.rotationSpeed = p.createVector(p.random(-0.02, 0.02), p.random(-0.02, 0.02), p.random(-0.02, 0.02));
            
            const shapes = ['torus', 'box', 'sphere', 'smiley', 'cone', 'cylinder'];
            this.shapeType = p.random(shapes);
          }

          drawSmiley(pg, size) {
              pg.push();
              // Billboard effect
              pg.rotateZ(-this.rotation.z);
              pg.rotateY(-this.rotation.y);
              pg.rotateX(-this.rotation.x);
              
              // Head
              pg.noStroke();
              pg.fill(255, 255, 0); 
              pg.ellipse(0, 0, size * 2, size * 2);
              
              const gl = pg._renderer.GL;
              gl.disable(gl.DEPTH_TEST);

              // Eyes
              pg.fill(0); 
              pg.ellipse(-size * 0.3, -size * 0.2, size * 0.2, size * 0.2);
              pg.ellipse(size * 0.3, -size * 0.2, size * 0.2, size * 0.2);

              // Smile
              pg.stroke(0);
              pg.strokeWeight(size * 0.1);
              pg.noFill();
              pg.arc(0, size * 0.1, size, size, 0, p.PI);
              
              gl.enable(gl.DEPTH_TEST);

              pg.pop();
          }

          updateAndDisplay(pg) {
            // --- FIX: Ring recycling logic is now here ---
            if (this.z > camZ + 50) {
              this.z -= totalRings * ringSpacing;
              this.randomize();
            }

            pg.push();
            
            pg.translate(this.x, this.y, this.z);
            
            if (this.shapeType !== 'smiley') {
                this.rotation.add(this.rotationSpeed);
                pg.rotateX(this.rotation.x);
                pg.rotateY(this.rotation.y);
                pg.rotateZ(this.rotation.z);
            }

            switch (this.shapeType) {
              case 'torus':
                pg.normalMaterial();
                pg.torus(this.size, this.size / 3);
                break;
              case 'box':
                pg.normalMaterial();
                pg.box(this.size);
                break;
              case 'sphere':
                pg.normalMaterial();
                pg.sphere(this.size * 0.7);
                break;
              case 'smiley':
                this.drawSmiley(pg, this.size * 0.8);
                break;
              case 'cone':
                pg.normalMaterial();
                pg.cone(this.size * 0.8, this.size * 1.5);
                break;
              case 'cylinder':
                pg.normalMaterial();
                pg.cylinder(this.size * 0.7, this.size * 1.2);
                break;
            }
            
            pg.pop();
          }
        }
      };

      // Create a new p5 instance with our sketch.
      new p5(sketch);
    </script>
  </body>
</html>
