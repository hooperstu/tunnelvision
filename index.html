<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Anaglyph Tunnel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/jdeboi/p5.anaglyph/dist/p5.anaglyph.min.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden; /* Prevent scrollbars */
        background-color: #000;
        font-family: 'Inter', sans-serif;
        color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      canvas {
        display: block;
        box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
      }
      .instructions {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.7);
        padding: 10px 20px;
        border-radius: 10px;
        font-size: 14px;
        text-align: center;
        pointer-events: none; /* Make sure it doesn't block mouse events for the canvas */
      }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
     <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div class="instructions">
        Put on your 3D glasses and move the mouse to steer through the tunnel.
    </div>
    <script>
      // This is p5.js "instance mode".
      const sketch = (p) => {
        let anaglyph;
        const rings = [];
        const totalRings = 200; 
        let camZ = 0; 
        const flightSpeed = 20;

        const stars = [];
        const totalStars = 2000;

        const ringSpacing = 100;
        const tunnelLength = totalRings * ringSpacing;

        p.setup = function() {
          p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
          p.noStroke();
          
          anaglyph = p.createAnaglyph(p);

          // Create the initial set of rings for the tunnel with new spacing
          for (let i = 0; i < totalRings; i++) {
            rings.push(new TunnelRing(i * -ringSpacing));
          }
          
          for (let i = 0; i < totalStars; i++) {
              stars.push({
                  x: p.random(-4000, 4000),
                  y: p.random(-4000, 4000),
                  z: p.random(0, -tunnelLength),
                  color: p.color(p.random(200, 255), p.random(200, 255), p.random(220, 255)),
                  twinkleOffset: p.random(p.TWO_PI)
              });
          }
        };

        p.draw = function() {
          camZ -= flightSpeed;
          anaglyph.draw(drawScene);
        };

        function drawStarfoxGrid(pg) {
            pg.push();
            pg.strokeWeight(2);

            const gridSize = 12000;
            const gridLines = 80;
            const gridSpacing = gridSize / gridLines;
            const gridY = 1200;

            pg.stroke(0, 255, 255, 150);
            for (let i = 0; i <= gridLines; i++) {
                const pos = -gridSize / 2 + i * gridSpacing;
                pg.line(pos, gridY, -gridSize, pos, gridY, gridSize);
                pg.line(-gridSize, gridY, pos, gridSize, gridY, pos);
            }

            pg.stroke(255, 0, 255, 150);
            pg.line(-gridSize, -gridY, -gridSize/2, -gridSize, -gridY, gridSize/2)
            for (let i = 0; i <= gridLines; i++) {
                const pos = -gridSize / 2 + i * gridSpacing;
                pg.line(pos, -gridY, -gridSize, pos, -gridY, gridSize);
                pg.line(-gridSize, -gridY, pos, gridSize, -gridY, pos);
            }

            pg.pop();
        }
        
        function drawScene(pg) {
          pg.background(0, 0, 10);
          
          const cameraX = 0;
          const cameraY = 0;

          const lookAtX = p.map(p.mouseX, 0, p.width, -p.width/2, p.width/2);
          const lookAtY = p.map(p.mouseY, 0, p.height, p.height/2, -p.height/2);
          const lookAtZ = camZ - 1000;

          pg.camera(cameraX, cameraY, camZ, 
                    lookAtX, lookAtY, lookAtZ, 
                    0, 1, 0);

          pg.ambientLight(50, 50, 50);
          pg.pointLight(255, 255, 255, 0, 0, camZ + 200);

          drawStarfoxGrid(pg);

          pg.push();
          for(const star of stars) {
              if (star.z > camZ) {
                  star.z -= tunnelLength;
                  star.x = p.random(-4000, 4000);
                  star.y = p.random(-4000, 4000);
              }
              
              pg.push();
              pg.ambientMaterial(star.color);
              pg.translate(star.x, star.y, star.z);
              const twinkleSize = 6 + p.sin(p.frameCount * 0.1 + star.twinkleOffset) * 4;
              pg.sphere(twinkleSize);
              pg.pop();
          }
          pg.pop();

          for (const ring of rings) {
            ring.updateAndDisplay(pg);
          }
        }
        
        p.windowResized = function() {
          p.resizeCanvas(p.windowWidth, p.windowHeight);
        };

        class TunnelRing {
          constructor(z) {
            this.z = z;
            this.randomize();
          }

          randomize() {
            this.angle = p.random(p.TWO_PI);
            this.radius = p.random(500, 1000);
            
            this.x = p.cos(this.angle) * this.radius;
            this.y = p.sin(this.angle) * this.radius;
            
            this.size = p.random(80, 150);
            
            this.rotation = p.createVector(p.random(p.TWO_PI), p.random(p.TWO_PI), p.random(p.TWO_PI));
            this.rotationSpeed = p.createVector(p.random(-0.02, 0.02), p.random(-0.02, 0.02), p.random(-0.02, 0.02));
            
            const shapes = ['torus', 'box', 'sphere', 'smiley', 'cone', 'cylinder'];
            this.shapeType = p.random(shapes);
          }

          // --- UPDATED: Smiley is now a flat, 2D shape ---
          drawSmiley(pg, size) {
              pg.push();
              // A "billboard" effect so the 2D shape always faces the camera.
              // We undo the object's rotation for this specific shape.
              pg.rotateZ(-this.rotation.z);
              pg.rotateY(-this.rotation.y);
              pg.rotateX(-this.rotation.x);
              
              // Head
              pg.emissiveMaterial(255, 255, 0); // Bright yellow, ignores lighting
              pg.noStroke();
              pg.ellipse(0, 0, size * 2, size * 2);

              // Eyes
              pg.emissiveMaterial(0); // Black
              pg.ellipse(-size * 0.3, -size * 0.2, size * 0.2, size * 0.2);
              pg.ellipse(size * 0.3, -size * 0.2, size * 0.2, size * 0.2);

              // Smile
              pg.stroke(0);
              pg.strokeWeight(size * 0.1);
              pg.noFill();
              pg.arc(0, size * 0.1, size, size, 0, p.PI);

              pg.pop();
          }

          updateAndDisplay(pg) {
            if (this.z > camZ + 200) {
              this.z -= totalRings * ringSpacing;
              this.randomize();
            }

            pg.push();
            
            pg.translate(this.x, this.y, this.z);
            
            // Only apply rotation if it's not a smiley face
            if (this.shapeType !== 'smiley') {
                this.rotation.add(this.rotationSpeed);
                pg.rotateX(this.rotation.x);
                pg.rotateY(this.rotation.y);
                pg.rotateZ(this.rotation.z);
            }

            switch (this.shapeType) {
              case 'torus':
                pg.normalMaterial();
                pg.torus(this.size, this.size / 3);
                break;
              case 'box':
                pg.normalMaterial();
                pg.box(this.size);
                break;
              case 'sphere':
                pg.normalMaterial();
                pg.sphere(this.size * 0.7);
                break;
              case 'smiley':
                // Call the new 2D smiley function
                this.drawSmiley(pg, this.size * 0.8);
                break;
              case 'cone':
                pg.normalMaterial();
                pg.cone(this.size * 0.8, this.size * 1.5);
                break;
              case 'cylinder':
                pg.normalMaterial();
                pg.cylinder(this.size * 0.7, this.size * 1.2);
                break;
            }
            
            pg.pop();
          }
        }
      };

      // Create a new p5 instance with our sketch.
      new p5(sketch);
    </script>
  </body>
</html>
